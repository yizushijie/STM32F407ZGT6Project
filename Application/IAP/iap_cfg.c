#include "iap_cfg.h"

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参数:
//////输出参数:
//////说		明： 为了实现Boot和App程序之间跳转，则必须在升级完成之后重新加载新的程序文件
//////////////////////////////////////////////////////////////////////////////
void MSR_MSP(UINT32_T addr)
{
	//---set Main Stack value 将主堆栈地址保存到MSP寄存器(R13)中
	__asm("msr msp, r0");

	//---跳转到lr中存放的地址处。bx是强制跳转指令 lr是连接寄存器，是STM32单片机的R14
	__asm("bx lr");
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能： IAP 跳转到 APP 函数
//////输入参数:
//////输出参数:
//////说		明： 跳转到应用程序 AppAddr:用户代码起始地址.
//////////////////////////////////////////////////////////////////////////////
void IAP_ToAPP(UINT32_T appAddr)
{
	//---定义一个函数类型的参数
	void(*iapToAppFunc)(void);

	//----检查栈顶地址是否合法.
	if (((*(VLTUINT32_T*)appAddr) & 0x2FFE0000) == 0x20000000)
	{
		//---关闭外设
		LL_RCC_DeInit();

		//---恢复NVIC为复位状态.使中断不再发生
		LL_NVIC_DeInit();

		//---关闭中断
		CLI();

		//---初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)
		MSR_MSP(*(VLTUINT32_T*)appAddr);

		//---用户代码区第二个字为程序开始地址(新程序复位地址) 
		iapToAppFunc = (iapFunc)*(VLTUINT32_T*)(appAddr + 4);

		//---设置PC指针为新程序复位中断函数的地址，往下执行
		iapToAppFunc();
	}
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能： IAP 跳转到 IAP 函数
//////输入参数:
//////输出参数:
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void IAP_ToIAP(UINT32_T iapAddr)
{
	//---定义一个函数类型的参数
	void(*iapToIapFunc)(void);

	//---关闭外设
	LL_RCC_DeInit();

	//---恢复NVIC为复位状态.使中断不再发生
	LL_NVIC_DeInit();

	//---关闭中断
	CLI();

	//进入用户级线程模式 进入软中断后才可以回到特权级线程模式
	__set_CONTROL(0);

	//---初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)
	MSR_MSP(*(VLTUINT32_T*)iapAddr);

	//---用户代码区第二个字为程序开始地址(新程序复位地址) 
	iapToIapFunc = (iapFunc) *(VLTUINT32_T*)(iapAddr + 4);

	//---设置PC指针为新程序复位中断函数的地址，往下执行
	iapToIapFunc();
}